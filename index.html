<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Procedural world generation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: red;
			}
		</style>

		<script type="text/javascript" src="js/dat.gui.js"></script>
		<script type="text/javascript" src="js/noise.js"></script>

		<!-- GUI -->
		<script type="text/javascript">
		GuiContent = function() {
			this.reseed = function() { reseedVertices(); };
		};

		var gui_content;

		window.onload = function() {
			gui_content = new GuiContent();
			var gui = new dat.GUI();
			gui.width = 330;
			gui.close();
			gui.add(gui_content, 'reseed');
		};
		</script>
		
	</head>

	<body>
		<div id="container"></div>

		<!-- Shaders -->
		<script type="x-shader/x-vertex" id="vertexshader">
			// switch on high precision floats
			#ifdef GL_ES
			precision highp float;
			#endif
			
			// uniforms
			uniform vec3 cameraPosWorldSpace;
			
			// varyings
			varying vec3 interpolatedNormalWorldSpace;
			varying vec4 fragWorldPos;
						
			void main()
			{		
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

				// Transformation of 'varyings'
				interpolatedNormalWorldSpace = normalize(mat3(modelMatrix) * normal);
				fragWorldPos = modelMatrix * vec4(position, 1.0);
			}
			
		</script>
		
		<script type="x-shader/x-fragment" id="fragmentshader">
			// switch on high precision floats
			#ifdef GL_ES
			precision highp float;
			#endif
			
			// uniforms
			uniform vec3 cameraPosWorldSpace;
			uniform float maxElevation;

			// varyings
			varying vec4 fragWorldPos;
			varying vec3 interpolatedNormalWorldSpace;

			vec3 lightDirectionWorldSpace = normalize(vec3(-1.0, -2.0, 0.0));
			vec3 diffuseLightColor = vec3(1.0, 1.0, 1.0);
			vec3 diffuseMaterialColor = vec3(1.0, 0.0, 0.0);
	
			void main()
			{

				float diffuseLighting = max(0.0, dot(interpolatedNormalWorldSpace, -lightDirectionWorldSpace));

				vec3 forestColor = vec3(0.5, 0.8, 0.3) * 0.5;
				vec3 mountainColor = vec3(0.9, 0.8, 0.7);

				vec3 groundColor = mix(forestColor, mountainColor, abs(fragWorldPos.y / maxElevation));
				gl_FragColor = vec4(diffuseLighting * groundColor, 1.0);
			}
		
		</script>
		
		<!-- End Shaders -->
		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var stats;
			var start;
			var camera, controls, scene, renderer;
			var uniforms;
			var plane_width  = 500;
			var plane_height = 500;
			var maxHeight = 0.0;
			var minHeight = 6666;
			var groundSurface, shaderMaterial;

			init();

			reseedVertices = function()
			{
				// Compute new displacement at this new timestep
				createBaseTerrain(groundSurface.geometry);

				// Mark the mesh for update in order for the changes to take effect
         		groundSurface.geometry.verticesNeedUpdate = true;
         		groundSurface.geometry.normalsNeedUpdate = true;
			};

			function animate()
			{
				requestAnimationFrame(animate);
				controls.update();

				render();
			}

			function vertexDisplacement(point_x, point_y, time)
			{
				var displacement = 0.0;
				var freqCount = 5;
				var noiseFreq = 0.0025;
				var noiseAmp = 150.0;

				// First frequency (ridges)
				if(freqCount > 0)
				{
					displacement +=  (0.5 - Math.abs(noise.perlin3(point_x * noiseFreq, point_y * noiseFreq, time)) ) * noiseAmp;
				}

				for(var i = 1; i < freqCount; ++i)
				{
					noiseFreq *= 3.5;
					noiseAmp *= 0.25;
					displacement += noise.perlin3(point_x * noiseFreq, point_y * noiseFreq, time) * noiseAmp;
				}

				return displacement;
			}

			/* 
			* Function createBaseTerrain creates the base terrain form using
			* procedural noise as vertex displacement. It also computes new face
			* normals for use in the shading.
			*/
			function createBaseTerrain(geometry)
			{
				var time = Date.now() - start;				
				for(var i = 0; i < geometry.vertices.length; ++i)
				{
					var point = geometry.vertices[i];
					var displacement = vertexDisplacement(point.x, point.y, time);
					geometry.vertices[i].z = displacement;

					maxHeight = (point.z > maxHeight) ? point.z : maxHeight;
					minHeight = (point.z < minHeight) ? point.z : minHeight;
				}

				// Recalculate face and vertex normals
				for(var i = 0; i < geometry.faces.length; ++i)
				{
					// Extract the three vertex indices of the face
					var ind1 = geometry.faces[i].a;
					var ind2 = geometry.faces[i].b;
					var ind3 = geometry.faces[i].c;

					// Extract the corresponging positions
					var vertPos1 = geometry.vertices[ind1];
					var vertPos2 = geometry.vertices[ind2];
					var vertPos3 = geometry.vertices[ind3];

					// Create edge vectors of the triangle
					var edgeVector1 = new THREE.Vector3();
					edgeVector1.subVectors(vertPos2, vertPos1);
					edgeVector1.divideScalar(edgeVector1.length());		// normalize

					var edgeVector2 = new THREE.Vector3();
					edgeVector2.subVectors(vertPos3, vertPos1);
					edgeVector2.divideScalar(edgeVector2.length());		// normalize

					// Calculate normal as the cross product of these
					var newNormal = new THREE.Vector3();
					newNormal.crossVectors(edgeVector1, edgeVector2);

					// Update stored face normal
					geometry.faces[i].normal = newNormal;

					// Add face normal as contribution to each vertex normal
					geometry.faces[i].vertexNormals[0] = newNormal;
					geometry.faces[i].vertexNormals[1] = newNormal;
					geometry.faces[i].vertexNormals[2] = newNormal;
				}
			}

			function init()
			{
				start = Date.now();

				// Camera
				camera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.set(0.0, 100.0, 0.0);

				// Scene
				scene = new THREE.Scene();

				// Shader uniforms
				uniforms = {
					// floats
					maxElevation: 			{ type: "f", value: maxHeight },
				    // integers
				    // vectors
				    cameraPosWorldSpace: 	{ type: "v3", value: new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z)},
				    // Textures
				};

				/* == Ground surface == *
				*  ==================== */

				// create ground surface material
				shaderMaterial = new THREE.ShaderMaterial({
					uniforms: uniforms,
					vertexShader:   $('#vertexshader').text(),
					fragmentShader: $('#fragmentshader').text(),
					wireframe: false
				});

				// Create ground surface mesh
				var geometry = new THREE.PlaneGeometry( plane_width, plane_height, 256, 256);

				// Create the base terrain
				createBaseTerrain(geometry);

				groundSurface = new THREE.Mesh( geometry, shaderMaterial );
				groundSurface.rotation.x = -3.1415 / 2.0;
				groundSurface.updateMatrix();
				groundSurface.matrixAutoUpdate = false;
				scene.add( groundSurface );

				var geometry2 = new THREE.PlaneGeometry( plane_width, plane_height, 1, 1);
				var groundSurface2 = new THREE.Mesh( geometry2, shaderMaterial );
				groundSurface2.rotation.x = -3.1415 / 2.0;
				groundSurface2.updateMatrix();
				groundSurface2.matrixAutoUpdate = false;
				//scene.add( groundSurface2 );

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setClearColor( 0x000000 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				// Controls
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.rotateSpeed = 0.5;
				controls.zoomSpeed = 0.4;
				controls.panSpeed = 0.1;

				camera.position.set(0.0, 250.0, 500.0);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				animate();
			}

			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function render()
			{
				uniforms.cameraPosWorldSpace.value = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
				uniforms.maxElevation.value = maxHeight;
				
				renderer.render( scene, camera );
				
				stats.update();
			}

		</script>

	</body>
</html>
